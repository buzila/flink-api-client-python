# coding: utf-8

"""
    Flink API Client

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FlinkApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_job_savepoint(self, body, jobid, **kwargs):  # noqa: E501
        """Triggers a savepoint, and optionally cancels the job afterwards  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_savepoint(body, jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SavepointTriggerRequestBody body: (required)
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_job_savepoint_with_http_info(body, jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_job_savepoint_with_http_info(body, jobid, **kwargs)  # noqa: E501
            return data

    def create_job_savepoint_with_http_info(self, body, jobid, **kwargs):  # noqa: E501
        """Triggers a savepoint, and optionally cancels the job afterwards  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_savepoint_with_http_info(body, jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SavepointTriggerRequestBody body: (required)
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job_savepoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_job_savepoint`")  # noqa: E501
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `create_job_savepoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/savepoints', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TriggerResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_jar(self, jarid, **kwargs):  # noqa: E501
        """Deletes a jar previously uploaded via '/jars/upload'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_jar(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_jar_with_http_info(jarid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_jar_with_http_info(jarid, **kwargs)  # noqa: E501
            return data

    def delete_jar_with_http_info(self, jarid, **kwargs):  # noqa: E501
        """Deletes a jar previously uploaded via '/jars/upload'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_jar_with_http_info(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jarid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_jar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jarid' is set
        if ('jarid' not in params or
                params['jarid'] is None):
            raise ValueError("Missing the required parameter `jarid` when calling `delete_jar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jarid' in params:
            path_params['jarid'] = params['jarid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jars/{jarid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_accumulators(self, jobid, **kwargs):  # noqa: E501
        """Returns the accumulators for all tasks of a job, aggregated across the respective subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_accumulators(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param bool include_serialized_value: Boolean value that specifies whether serialized user task accumulators should be included in the response
        :return: JobAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_accumulators_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_accumulators_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_accumulators_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the accumulators for all tasks of a job, aggregated across the respective subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_accumulators_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param bool include_serialized_value: Boolean value that specifies whether serialized user task accumulators should be included in the response
        :return: JobAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'include_serialized_value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_accumulators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_accumulators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []
        if 'include_serialized_value' in params:
            query_params.append(('includeSerializedValue', params['include_serialized_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/accumulators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobAccumulatorsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_aggregated_subtask_metrics(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Provides access to aggregated subtask metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_aggregated_subtask_metrics(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str subtasks: Comma-separated list of integer ranges (e.g. \"1,3,5-9\") to select specific subtasks
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_aggregated_subtask_metrics_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_aggregated_subtask_metrics_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_aggregated_subtask_metrics_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Provides access to aggregated subtask metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_aggregated_subtask_metrics_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str subtasks: Comma-separated list of integer ranges (e.g. \"1,3,5-9\") to select specific subtasks
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'get', 'agg', 'subtasks']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_aggregated_subtask_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_aggregated_subtask_metrics`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_aggregated_subtask_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501
        if 'agg' in params:
            query_params.append(('agg', params['agg']))  # noqa: E501
        if 'subtasks' in params:
            query_params.append(('subtasks', params['subtasks']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_checkpoint_details(self, jobid, checkpointid, **kwargs):  # noqa: E501
        """Returns details for a checkpoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoint_details(jobid, checkpointid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int checkpointid: Long value that identifies a checkpoint (required)
        :return: CheckpointStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_checkpoint_details_with_http_info(jobid, checkpointid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_checkpoint_details_with_http_info(jobid, checkpointid, **kwargs)  # noqa: E501
            return data

    def get_job_checkpoint_details_with_http_info(self, jobid, checkpointid, **kwargs):  # noqa: E501
        """Returns details for a checkpoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoint_details_with_http_info(jobid, checkpointid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int checkpointid: Long value that identifies a checkpoint (required)
        :return: CheckpointStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'checkpointid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_checkpoint_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_checkpoint_details`")  # noqa: E501
        # verify the required parameter 'checkpointid' is set
        if ('checkpointid' not in params or
                params['checkpointid'] is None):
            raise ValueError("Missing the required parameter `checkpointid` when calling `get_job_checkpoint_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'checkpointid' in params:
            path_params['checkpointid'] = params['checkpointid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/checkpoints/details/{checkpointid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CheckpointStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_checkpoint_statistics(self, jobid, checkpointid, vertexid, **kwargs):  # noqa: E501
        """Returns checkpoint statistics for a task and its subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoint_statistics(jobid, checkpointid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int checkpointid: Long value that identifies a checkpoint (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: TaskCheckpointStatisticsWithSubtaskDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_checkpoint_statistics_with_http_info(jobid, checkpointid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_checkpoint_statistics_with_http_info(jobid, checkpointid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_checkpoint_statistics_with_http_info(self, jobid, checkpointid, vertexid, **kwargs):  # noqa: E501
        """Returns checkpoint statistics for a task and its subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoint_statistics_with_http_info(jobid, checkpointid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int checkpointid: Long value that identifies a checkpoint (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: TaskCheckpointStatisticsWithSubtaskDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'checkpointid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_checkpoint_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_checkpoint_statistics`")  # noqa: E501
        # verify the required parameter 'checkpointid' is set
        if ('checkpointid' not in params or
                params['checkpointid'] is None):
            raise ValueError("Missing the required parameter `checkpointid` when calling `get_job_checkpoint_statistics`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_checkpoint_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'checkpointid' in params:
            path_params['checkpointid'] = params['checkpointid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/checkpoints/details/{checkpointid}/subtasks/{vertexid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskCheckpointStatisticsWithSubtaskDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_checkpoints(self, jobid, **kwargs):  # noqa: E501
        """Returns checkpointing statistics for a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoints(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: CheckpointingStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_checkpoints_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_checkpoints_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_checkpoints_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns checkpointing statistics for a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoints_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: CheckpointingStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_checkpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_checkpoints`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/checkpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CheckpointingStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_checkpoints_config(self, jobid, **kwargs):  # noqa: E501
        """Returns the checkpointing configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoints_config(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: CheckpointConfigInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_checkpoints_config_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_checkpoints_config_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_checkpoints_config_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the checkpointing configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_checkpoints_config_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: CheckpointConfigInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_checkpoints_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_checkpoints_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/checkpoints/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CheckpointConfigInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_config(self, jobid, **kwargs):  # noqa: E501
        """Returns the configuration of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_config(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_config_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_config_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_config_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the configuration of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_config_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_details(self, jobid, **kwargs):  # noqa: E501
        """Returns details of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_details(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_details_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_details_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_details_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns details of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_details_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDetailsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_exceptions(self, jobid, **kwargs):  # noqa: E501
        """Returns the non-recoverable exceptions that have been observed by the job. The truncated flag defines whether more exceptions occurred, but are not listed, because the response would otherwise get too big  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_exceptions(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobExceptionsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_exceptions_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_exceptions_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_exceptions_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the non-recoverable exceptions that have been observed by the job. The truncated flag defines whether more exceptions occurred, but are not listed, because the response would otherwise get too big  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_exceptions_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobExceptionsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_exceptions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_exceptions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/exceptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobExceptionsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_manager_metrics(self, **kwargs):  # noqa: E501
        """Provides access to job manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_manager_metrics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_manager_metrics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_job_manager_metrics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_job_manager_metrics_with_http_info(self, **kwargs):  # noqa: E501
        """Provides access to job manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_manager_metrics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_manager_metrics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobmanager/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_metrics(self, jobid, **kwargs):  # noqa: E501
        """Provides access to job metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_metrics(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_metrics_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_metrics_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_metrics_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Provides access to job metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_metrics_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'get']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_plan(self, jobid, **kwargs):  # noqa: E501
        """Returns the dataflow plan of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_plan(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobPlanInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_plan_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_plan_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_plan_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the dataflow plan of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_plan_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobPlanInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/plan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobPlanInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_rescaling_status(self, jobid, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a rescaling operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_rescaling_status(jobid, triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_rescaling_status_with_http_info(jobid, triggerid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_rescaling_status_with_http_info(jobid, triggerid, **kwargs)  # noqa: E501
            return data

    def get_job_rescaling_status_with_http_info(self, jobid, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a rescaling operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_rescaling_status_with_http_info(jobid, triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'triggerid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_rescaling_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_rescaling_status`")  # noqa: E501
        # verify the required parameter 'triggerid' is set
        if ('triggerid' not in params or
                params['triggerid'] is None):
            raise ValueError("Missing the required parameter `triggerid` when calling `get_job_rescaling_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'triggerid' in params:
            path_params['triggerid'] = params['triggerid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/rescaling/{triggerid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsynchronousOperationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_result(self, jobid, **kwargs):  # noqa: E501
        """Returns the result of a job execution. Gives access to the execution time of the job and to all accumulators created by this job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_result(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobExecutionResultResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_result_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_result_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def get_job_result_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Returns the result of a job execution. Gives access to the execution time of the job and to all accumulators created by this job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_result_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :return: JobExecutionResultResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/execution-result', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobExecutionResultResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_savepoint_status(self, jobid, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a savepoint operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_savepoint_status(jobid, triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_savepoint_status_with_http_info(jobid, triggerid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_savepoint_status_with_http_info(jobid, triggerid, **kwargs)  # noqa: E501
            return data

    def get_job_savepoint_status_with_http_info(self, jobid, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a savepoint operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_savepoint_status_with_http_info(jobid, triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'triggerid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_savepoint_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_savepoint_status`")  # noqa: E501
        # verify the required parameter 'triggerid' is set
        if ('triggerid' not in params or
                params['triggerid'] is None):
            raise ValueError("Missing the required parameter `triggerid` when calling `get_job_savepoint_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'triggerid' in params:
            path_params['triggerid'] = params['triggerid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/savepoints/{triggerid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsynchronousOperationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_accumulators(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns all user-defined accumulators for all subtasks of a task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_accumulators(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: SubtasksAllAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_accumulators_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_accumulators_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_accumulators_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns all user-defined accumulators for all subtasks of a task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_accumulators_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: SubtasksAllAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_accumulators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_accumulators`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_accumulators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/accumulators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubtasksAllAccumulatorsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_attempt_accumulators(self, jobid, vertexid, subtaskindex, attempt, **kwargs):  # noqa: E501
        """Returns the accumulators of an execution attempt of a subtask. Multiple execution attempts happen in case of failure/recovery  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_attempt_accumulators(jobid, vertexid, subtaskindex, attempt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param int attempt: Positive integer value that identifies an execution attempt (required)
        :return: SubtaskExecutionAttemptAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_attempt_accumulators_with_http_info(jobid, vertexid, subtaskindex, attempt, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_attempt_accumulators_with_http_info(jobid, vertexid, subtaskindex, attempt, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_attempt_accumulators_with_http_info(self, jobid, vertexid, subtaskindex, attempt, **kwargs):  # noqa: E501
        """Returns the accumulators of an execution attempt of a subtask. Multiple execution attempts happen in case of failure/recovery  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_attempt_accumulators_with_http_info(jobid, vertexid, subtaskindex, attempt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param int attempt: Positive integer value that identifies an execution attempt (required)
        :return: SubtaskExecutionAttemptAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'subtaskindex', 'attempt']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_attempt_accumulators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_attempt_accumulators`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_attempt_accumulators`")  # noqa: E501
        # verify the required parameter 'subtaskindex' is set
        if ('subtaskindex' not in params or
                params['subtaskindex'] is None):
            raise ValueError("Missing the required parameter `subtaskindex` when calling `get_job_subtask_attempt_accumulators`")  # noqa: E501
        # verify the required parameter 'attempt' is set
        if ('attempt' not in params or
                params['attempt'] is None):
            raise ValueError("Missing the required parameter `attempt` when calling `get_job_subtask_attempt_accumulators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501
        if 'subtaskindex' in params:
            path_params['subtaskindex'] = params['subtaskindex']  # noqa: E501
        if 'attempt' in params:
            path_params['attempt'] = params['attempt']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/{subtaskindex}/attempts/:attempt/accumulators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubtaskExecutionAttemptAccumulatorsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_attempt_details(self, jobid, vertexid, subtaskindex, attempt, **kwargs):  # noqa: E501
        """Returns details of an execution attempt of a subtask. Multiple execution attempts happen in case of failure/recovery  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_attempt_details(jobid, vertexid, subtaskindex, attempt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param int attempt: Positive integer value that identifies an execution attempt (required)
        :return: SubtaskExecutionAttemptDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_attempt_details_with_http_info(jobid, vertexid, subtaskindex, attempt, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_attempt_details_with_http_info(jobid, vertexid, subtaskindex, attempt, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_attempt_details_with_http_info(self, jobid, vertexid, subtaskindex, attempt, **kwargs):  # noqa: E501
        """Returns details of an execution attempt of a subtask. Multiple execution attempts happen in case of failure/recovery  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_attempt_details_with_http_info(jobid, vertexid, subtaskindex, attempt, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param int attempt: Positive integer value that identifies an execution attempt (required)
        :return: SubtaskExecutionAttemptDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'subtaskindex', 'attempt']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_attempt_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_attempt_details`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_attempt_details`")  # noqa: E501
        # verify the required parameter 'subtaskindex' is set
        if ('subtaskindex' not in params or
                params['subtaskindex'] is None):
            raise ValueError("Missing the required parameter `subtaskindex` when calling `get_job_subtask_attempt_details`")  # noqa: E501
        # verify the required parameter 'attempt' is set
        if ('attempt' not in params or
                params['attempt'] is None):
            raise ValueError("Missing the required parameter `attempt` when calling `get_job_subtask_attempt_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501
        if 'subtaskindex' in params:
            path_params['subtaskindex'] = params['subtaskindex']  # noqa: E501
        if 'attempt' in params:
            path_params['attempt'] = params['attempt']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/{subtaskindex}/attempts/:attempt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubtaskExecutionAttemptDetailsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_details(self, jobid, vertexid, subtaskindex, **kwargs):  # noqa: E501
        """Returns details of the current or latest execution attempt of a subtask  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_details(jobid, vertexid, subtaskindex, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :return: SubtaskExecutionAttemptDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_details_with_http_info(jobid, vertexid, subtaskindex, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_details_with_http_info(jobid, vertexid, subtaskindex, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_details_with_http_info(self, jobid, vertexid, subtaskindex, **kwargs):  # noqa: E501
        """Returns details of the current or latest execution attempt of a subtask  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_details_with_http_info(jobid, vertexid, subtaskindex, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :return: SubtaskExecutionAttemptDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'subtaskindex']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_details`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_details`")  # noqa: E501
        # verify the required parameter 'subtaskindex' is set
        if ('subtaskindex' not in params or
                params['subtaskindex'] is None):
            raise ValueError("Missing the required parameter `subtaskindex` when calling `get_job_subtask_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501
        if 'subtaskindex' in params:
            path_params['subtaskindex'] = params['subtaskindex']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/{subtaskindex}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubtaskExecutionAttemptDetailsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_metrics(self, jobid, vertexid, subtaskindex, **kwargs):  # noqa: E501
        """Provides access to subtask metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_metrics(jobid, vertexid, subtaskindex, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_metrics_with_http_info(jobid, vertexid, subtaskindex, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_metrics_with_http_info(jobid, vertexid, subtaskindex, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_metrics_with_http_info(self, jobid, vertexid, subtaskindex, **kwargs):  # noqa: E501
        """Provides access to subtask metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_metrics_with_http_info(jobid, vertexid, subtaskindex, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param int subtaskindex: Positive integer value that identifies a subtask (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'subtaskindex', 'get']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_metrics`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_metrics`")  # noqa: E501
        # verify the required parameter 'subtaskindex' is set
        if ('subtaskindex' not in params or
                params['subtaskindex'] is None):
            raise ValueError("Missing the required parameter `subtaskindex` when calling `get_job_subtask_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501
        if 'subtaskindex' in params:
            path_params['subtaskindex'] = params['subtaskindex']  # noqa: E501

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasks/{subtaskindex}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_subtask_times(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns time-related information for all subtasks of a task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_times(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: SubtasksTimesInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_subtask_times_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_subtask_times_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_subtask_times_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns time-related information for all subtasks of a task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_subtask_times_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: SubtasksTimesInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_subtask_times" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_subtask_times`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_subtask_times`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/subtasktimes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubtasksTimesInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_task_accumulators(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns user-defined accumulators of a task, aggregated across all subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_accumulators(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_task_accumulators_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_task_accumulators_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_task_accumulators_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns user-defined accumulators of a task, aggregated across all subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_accumulators_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexAccumulatorsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_task_accumulators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_task_accumulators`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_task_accumulators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/accumulators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobVertexAccumulatorsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_task_backpressure(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns back-pressure information for a job, and may initiate back-pressure sampling if necessary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_backpressure(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexBackPressureInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_task_backpressure_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_task_backpressure_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_task_backpressure_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns back-pressure information for a job, and may initiate back-pressure sampling if necessary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_backpressure_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexBackPressureInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_task_backpressure" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_task_backpressure`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_task_backpressure`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/backpressure', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobVertexBackPressureInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_task_details(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns details for a task, with a summary for each of its subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_details(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_task_details_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_task_details_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_task_details_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns details for a task, with a summary for each of its subtasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_details_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_task_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_task_details`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_task_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobVertexDetailsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_task_details_by_task_manager(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns task information aggregated by task manager  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_details_by_task_manager(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexTaskManagersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_task_details_by_task_manager_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_task_details_by_task_manager_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_task_details_by_task_manager_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Returns task information aggregated by task manager  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_details_by_task_manager_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :return: JobVertexTaskManagersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_task_details_by_task_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_task_details_by_task_manager`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_task_details_by_task_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/taskmanagers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobVertexTaskManagersInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_task_metrics(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Provides access to task metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_metrics(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_task_metrics_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_task_metrics_with_http_info(jobid, vertexid, **kwargs)  # noqa: E501
            return data

    def get_job_task_metrics_with_http_info(self, jobid, vertexid, **kwargs):  # noqa: E501
        """Provides access to task metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_task_metrics_with_http_info(jobid, vertexid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str vertexid: 32-character hexadecimal string value that identifies a job vertex (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'vertexid', 'get']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_task_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `get_job_task_metrics`")  # noqa: E501
        # verify the required parameter 'vertexid' is set
        if ('vertexid' not in params or
                params['vertexid'] is None):
            raise ValueError("Missing the required parameter `vertexid` when calling `get_job_task_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501
        if 'vertexid' in params:
            path_params['vertexid'] = params['vertexid']  # noqa: E501

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/vertices/{vertexid}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_jobs(self, **kwargs):  # noqa: E501
        """Returns an overview over all jobs and their current state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: JobIdsWithStatusOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Returns an overview over all jobs and their current state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: JobIdsWithStatusOverview
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobIdsWithStatusOverview',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_jobs_metrics(self, **kwargs):  # noqa: E501
        """Provides access to aggregated job metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_metrics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str jobs: Comma-separated list of 32-character hexadecimal strings to select specific jobs
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_jobs_metrics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_jobs_metrics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_jobs_metrics_with_http_info(self, **kwargs):  # noqa: E501
        """Provides access to aggregated job metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_metrics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str jobs: Comma-separated list of 32-character hexadecimal strings to select specific jobs
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get', 'agg', 'jobs']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_metrics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501
        if 'agg' in params:
            query_params.append(('agg', params['agg']))  # noqa: E501
        if 'jobs' in params:
            query_params.append(('jobs', params['jobs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_jobs_overview(self, **kwargs):  # noqa: E501
        """Returns an overview over all jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_overview(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MultipleJobsDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_jobs_overview_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_jobs_overview_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_jobs_overview_with_http_info(self, **kwargs):  # noqa: E501
        """Returns an overview over all jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_overview_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MultipleJobsDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_overview" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/overview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultipleJobsDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_overview(self, **kwargs):  # noqa: E501
        """Returns an overview over the Flink cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overview(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterOverviewWithVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_overview_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_overview_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_overview_with_http_info(self, **kwargs):  # noqa: E501
        """Returns an overview over the Flink cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overview_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ClusterOverviewWithVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overview" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/overview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterOverviewWithVersion',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_savepoint_disposal_status(self, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a savepoint disposal operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_savepoint_disposal_status(triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_savepoint_disposal_status_with_http_info(triggerid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_savepoint_disposal_status_with_http_info(triggerid, **kwargs)  # noqa: E501
            return data

    def get_savepoint_disposal_status_with_http_info(self, triggerid, **kwargs):  # noqa: E501
        """Returns the status of a savepoint disposal operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_savepoint_disposal_status_with_http_info(triggerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str triggerid: 32-character hexadecimal string that identifies an asynchronous operation trigger ID. The ID was returned then the operation was triggered (required)
        :return: AsynchronousOperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['triggerid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_savepoint_disposal_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'triggerid' is set
        if ('triggerid' not in params or
                params['triggerid'] is None):
            raise ValueError("Missing the required parameter `triggerid` when calling `get_savepoint_disposal_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'triggerid' in params:
            path_params['triggerid'] = params['triggerid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/savepoint-disposal/{triggerid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsynchronousOperationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_manager_aggregated_metrics(self, **kwargs):  # noqa: E501
        """Provides access to aggregated task manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_aggregated_metrics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str taskmanagers: Comma-separated list of 32-character hexadecimal strings to select specific task managers
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_manager_aggregated_metrics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_task_manager_aggregated_metrics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_task_manager_aggregated_metrics_with_http_info(self, **kwargs):  # noqa: E501
        """Provides access to aggregated task manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_aggregated_metrics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str get: Comma-separated list of string values to select specific metrics
        :param str agg: Comma-separated list of aggregation modes which should be calculated. Available aggregations are: \"min, max, sum, avg\"
        :param str taskmanagers: Comma-separated list of 32-character hexadecimal strings to select specific task managers
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get', 'agg', 'taskmanagers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_manager_aggregated_metrics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501
        if 'agg' in params:
            query_params.append(('agg', params['agg']))  # noqa: E501
        if 'taskmanagers' in params:
            query_params.append(('taskmanagers', params['taskmanagers']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/taskmanagers/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_manager_details(self, taskmanagerid, **kwargs):  # noqa: E501
        """Returns details for a task manager  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_details(taskmanagerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskmanagerid: 32-character hexadecimal string that identifies a task manager (required)
        :return: TaskManagerDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_manager_details_with_http_info(taskmanagerid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_task_manager_details_with_http_info(taskmanagerid, **kwargs)  # noqa: E501
            return data

    def get_task_manager_details_with_http_info(self, taskmanagerid, **kwargs):  # noqa: E501
        """Returns details for a task manager  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_details_with_http_info(taskmanagerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskmanagerid: 32-character hexadecimal string that identifies a task manager (required)
        :return: TaskManagerDetailsInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['taskmanagerid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_manager_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'taskmanagerid' is set
        if ('taskmanagerid' not in params or
                params['taskmanagerid'] is None):
            raise ValueError("Missing the required parameter `taskmanagerid` when calling `get_task_manager_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'taskmanagerid' in params:
            path_params['taskmanagerid'] = params['taskmanagerid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/taskmanagers/{taskmanagerid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskManagerDetailsInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_manager_metrics(self, taskmanagerid, **kwargs):  # noqa: E501
        """Provides access to task manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_metrics(taskmanagerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskmanagerid: 32-character hexadecimal string that identifies a task manager (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_manager_metrics_with_http_info(taskmanagerid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_task_manager_metrics_with_http_info(taskmanagerid, **kwargs)  # noqa: E501
            return data

    def get_task_manager_metrics_with_http_info(self, taskmanagerid, **kwargs):  # noqa: E501
        """Provides access to task manager metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manager_metrics_with_http_info(taskmanagerid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskmanagerid: 32-character hexadecimal string that identifies a task manager (required)
        :param str get: Comma-separated list of string values to select specific metrics
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['taskmanagerid', 'get']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_manager_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'taskmanagerid' is set
        if ('taskmanagerid' not in params or
                params['taskmanagerid'] is None):
            raise ValueError("Missing the required parameter `taskmanagerid` when calling `get_task_manager_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'taskmanagerid' in params:
            path_params['taskmanagerid'] = params['taskmanagerid']  # noqa: E501

        query_params = []
        if 'get' in params:
            query_params.append(('get', params['get']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/taskmanagers/{taskmanagerid}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_managers_overview(self, **kwargs):  # noqa: E501
        """Returns an overview over all task managers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_managers_overview(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TaskManagersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_managers_overview_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_task_managers_overview_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_task_managers_overview_with_http_info(self, **kwargs):  # noqa: E501
        """Returns an overview over all task managers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_managers_overview_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TaskManagersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_managers_overview" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/taskmanagers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskManagersInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_jars(self, **kwargs):  # noqa: E501
        """Returns a list of all jars previously uploaded via '/jars/upload'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jars(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: JarListInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_jars_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_jars_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_jars_with_http_info(self, **kwargs):  # noqa: E501
        """Returns a list of all jars previously uploaded via '/jars/upload'  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jars_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: JarListInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_jars" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jars', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JarListInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_jar(self, jarid, **kwargs):  # noqa: E501
        """Submits a job by running a jar previously uploaded via '/jars/upload'. Program arguments can be passed both via the JSON request (recommended) or query parameters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_jar(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :param bool allow_non_restored_state: Boolean value that specifies whether the job submission should be rejected if the savepoint contains state that cannot be mapped back to the job
        :param str savepoint_path: Comma-separated list of program arguments
        :param str program_args: Deprecated, please use 'programArg' instead. String value that specifies the arguments for the program or plan
        :param str program_arg: Comma-separated list of program arguments
        :param str entry_class: String value that specifies the fully qualified name of the entry point class. Overrides the class defined in the jar file manifest
        :param int parallelism: Positive integer value that specifies the desired parallelism for the job
        :return: JarRunResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.run_jar_with_http_info(jarid, **kwargs)  # noqa: E501
        else:
            (data) = self.run_jar_with_http_info(jarid, **kwargs)  # noqa: E501
            return data

    def run_jar_with_http_info(self, jarid, **kwargs):  # noqa: E501
        """Submits a job by running a jar previously uploaded via '/jars/upload'. Program arguments can be passed both via the JSON request (recommended) or query parameters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_jar_with_http_info(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :param bool allow_non_restored_state: Boolean value that specifies whether the job submission should be rejected if the savepoint contains state that cannot be mapped back to the job
        :param str savepoint_path: Comma-separated list of program arguments
        :param str program_args: Deprecated, please use 'programArg' instead. String value that specifies the arguments for the program or plan
        :param str program_arg: Comma-separated list of program arguments
        :param str entry_class: String value that specifies the fully qualified name of the entry point class. Overrides the class defined in the jar file manifest
        :param int parallelism: Positive integer value that specifies the desired parallelism for the job
        :return: JarRunResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jarid', 'allow_non_restored_state', 'savepoint_path', 'program_args', 'program_arg', 'entry_class', 'parallelism']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_jar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jarid' is set
        if ('jarid' not in params or
                params['jarid'] is None):
            raise ValueError("Missing the required parameter `jarid` when calling `run_jar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jarid' in params:
            path_params['jarid'] = params['jarid']  # noqa: E501

        query_params = []
        if 'allow_non_restored_state' in params:
            query_params.append(('allowNonRestoredState', params['allow_non_restored_state']))  # noqa: E501
        if 'savepoint_path' in params:
            query_params.append(('savepointPath', params['savepoint_path']))  # noqa: E501
        if 'program_args' in params:
            query_params.append(('program-args', params['program_args']))  # noqa: E501
        if 'program_arg' in params:
            query_params.append(('programArg', params['program_arg']))  # noqa: E501
        if 'entry_class' in params:
            query_params.append(('entry-class', params['entry_class']))  # noqa: E501
        if 'parallelism' in params:
            query_params.append(('parallelism', params['parallelism']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jars/{jarid}/run', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JarRunResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_config(self, **kwargs):  # noqa: E501
        """Returns the configuration of the WebUI  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DashboardConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.show_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def show_config_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the configuration of the WebUI  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DashboardConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DashboardConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_job_manager_config(self, **kwargs):  # noqa: E501
        """Returns the cluster configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_job_manager_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ClusterConfigurationInfoEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_job_manager_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.show_job_manager_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def show_job_manager_config_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the cluster configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_job_manager_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ClusterConfigurationInfoEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_job_manager_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobmanager/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClusterConfigurationInfoEntry]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_plan(self, jarid, **kwargs):  # noqa: E501
        """Returns the dataflow plan of a job contained in a jar previously uploaded via '/jars/upload'. Program arguments can be passed both via the JSON request (recommended) or query parameters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_plan(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :param str program_args: Deprecated, please use 'programArg' instead. String value that specifies the arguments for the program or plan
        :param str program_arg: Comma-separated list of program arguments
        :param str entry_class: String value that specifies the fully qualified name of the entry point class. Overrides the class defined in the jar file manifest
        :param int parallelism: Positive integer value that specifies the desired parallelism for the job
        :return: JobPlanInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_plan_with_http_info(jarid, **kwargs)  # noqa: E501
        else:
            (data) = self.show_plan_with_http_info(jarid, **kwargs)  # noqa: E501
            return data

    def show_plan_with_http_info(self, jarid, **kwargs):  # noqa: E501
        """Returns the dataflow plan of a job contained in a jar previously uploaded via '/jars/upload'. Program arguments can be passed both via the JSON request (recommended) or query parameters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_plan_with_http_info(jarid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarid: String value that identifies a jar. When uploading the jar a path is returned, where the filename is the ID. This value is equivalent to the `id` field in the list of uploaded jars (/jars) (required)
        :param str program_args: Deprecated, please use 'programArg' instead. String value that specifies the arguments for the program or plan
        :param str program_arg: Comma-separated list of program arguments
        :param str entry_class: String value that specifies the fully qualified name of the entry point class. Overrides the class defined in the jar file manifest
        :param int parallelism: Positive integer value that specifies the desired parallelism for the job
        :return: JobPlanInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jarid', 'program_args', 'program_arg', 'entry_class', 'parallelism']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jarid' is set
        if ('jarid' not in params or
                params['jarid'] is None):
            raise ValueError("Missing the required parameter `jarid` when calling `show_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jarid' in params:
            path_params['jarid'] = params['jarid']  # noqa: E501

        query_params = []
        if 'program_args' in params:
            query_params.append(('program-args', params['program_args']))  # noqa: E501
        if 'program_arg' in params:
            query_params.append(('programArg', params['program_arg']))  # noqa: E501
        if 'entry_class' in params:
            query_params.append(('entry-class', params['entry_class']))  # noqa: E501
        if 'parallelism' in params:
            query_params.append(('parallelism', params['parallelism']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jars/{jarid}/plan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobPlanInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shutdown_cluster(self, **kwargs):  # noqa: E501
        """Shuts-down the cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_cluster(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.shutdown_cluster_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shutdown_cluster_with_http_info(**kwargs)  # noqa: E501
            return data

    def shutdown_cluster_with_http_info(self, **kwargs):  # noqa: E501
        """Shuts-down the cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_cluster_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown_cluster" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cluster', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def submit_job(self, job_graph_file_name, job_jar_file_names, job_artifact_file_names, **kwargs):  # noqa: E501
        """Submits a job. This call is primarily intended to be used by the Flink client. This call expects a multipart/form-data request that consists of file uploads for the serialized JobGraph, jars and distributed cache artifacts and an attribute named \"request\" for the JSON payload  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.submit_job(job_graph_file_name, job_jar_file_names, job_artifact_file_names, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_graph_file_name: (required)
        :param list[str] job_jar_file_names: (required)
        :param list[JobsJobArtifactFileNames] job_artifact_file_names: (required)
        :return: JobSubmitResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.submit_job_with_http_info(job_graph_file_name, job_jar_file_names, job_artifact_file_names, **kwargs)  # noqa: E501
        else:
            (data) = self.submit_job_with_http_info(job_graph_file_name, job_jar_file_names, job_artifact_file_names, **kwargs)  # noqa: E501
            return data

    def submit_job_with_http_info(self, job_graph_file_name, job_jar_file_names, job_artifact_file_names, **kwargs):  # noqa: E501
        """Submits a job. This call is primarily intended to be used by the Flink client. This call expects a multipart/form-data request that consists of file uploads for the serialized JobGraph, jars and distributed cache artifacts and an attribute named \"request\" for the JSON payload  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.submit_job_with_http_info(job_graph_file_name, job_jar_file_names, job_artifact_file_names, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_graph_file_name: (required)
        :param list[str] job_jar_file_names: (required)
        :param list[JobsJobArtifactFileNames] job_artifact_file_names: (required)
        :return: JobSubmitResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_graph_file_name', 'job_jar_file_names', 'job_artifact_file_names']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method submit_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_graph_file_name' is set
        if ('job_graph_file_name' not in params or
                params['job_graph_file_name'] is None):
            raise ValueError("Missing the required parameter `job_graph_file_name` when calling `submit_job`")  # noqa: E501
        # verify the required parameter 'job_jar_file_names' is set
        if ('job_jar_file_names' not in params or
                params['job_jar_file_names'] is None):
            raise ValueError("Missing the required parameter `job_jar_file_names` when calling `submit_job`")  # noqa: E501
        # verify the required parameter 'job_artifact_file_names' is set
        if ('job_artifact_file_names' not in params or
                params['job_artifact_file_names'] is None):
            raise ValueError("Missing the required parameter `job_artifact_file_names` when calling `submit_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'job_graph_file_name' in params:
            local_var_files['jobGraphFileName'] = params['job_graph_file_name']  # noqa: E501
        if 'job_jar_file_names' in params:
            form_params.append(('jobJarFileNames', params['job_jar_file_names']))  # noqa: E501
            collection_formats['jobJarFileNames'] = 'multi'  # noqa: E501
        if 'job_artifact_file_names' in params:
            form_params.append(('jobArtifactFileNames', params['job_artifact_file_names']))  # noqa: E501
            collection_formats['jobArtifactFileNames'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobSubmitResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_job(self, jobid, **kwargs):  # noqa: E501
        """Terminates a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str mode: String value that specifies the termination mode. Supported values are: \"cancel, stop\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.terminate_job_with_http_info(jobid, **kwargs)  # noqa: E501
        else:
            (data) = self.terminate_job_with_http_info(jobid, **kwargs)  # noqa: E501
            return data

    def terminate_job_with_http_info(self, jobid, **kwargs):  # noqa: E501
        """Terminates a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_with_http_info(jobid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param str mode: String value that specifies the termination mode. Supported values are: \"cancel, stop\"
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `terminate_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def trigger_job_rescaling(self, jobid, parallelism, **kwargs):  # noqa: E501
        """Triggers the rescaling of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_job_rescaling(jobid, parallelism, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int parallelism: Positive integer value that specifies the desired parallelism (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.trigger_job_rescaling_with_http_info(jobid, parallelism, **kwargs)  # noqa: E501
        else:
            (data) = self.trigger_job_rescaling_with_http_info(jobid, parallelism, **kwargs)  # noqa: E501
            return data

    def trigger_job_rescaling_with_http_info(self, jobid, parallelism, **kwargs):  # noqa: E501
        """Triggers the rescaling of a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_job_rescaling_with_http_info(jobid, parallelism, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobid: 32-character hexadecimal string value that identifies a job (required)
        :param int parallelism: Positive integer value that specifies the desired parallelism (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobid', 'parallelism']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trigger_job_rescaling" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobid' is set
        if ('jobid' not in params or
                params['jobid'] is None):
            raise ValueError("Missing the required parameter `jobid` when calling `trigger_job_rescaling`")  # noqa: E501
        # verify the required parameter 'parallelism' is set
        if ('parallelism' not in params or
                params['parallelism'] is None):
            raise ValueError("Missing the required parameter `parallelism` when calling `trigger_job_rescaling`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobid' in params:
            path_params['jobid'] = params['jobid']  # noqa: E501

        query_params = []
        if 'parallelism' in params:
            query_params.append(('parallelism', params['parallelism']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobid}/rescaling', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TriggerResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def trigger_savepoint_disposal(self, body, **kwargs):  # noqa: E501
        """Triggers the desposal of a savepoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_savepoint_disposal(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SavepointDisposalRequest body: (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.trigger_savepoint_disposal_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.trigger_savepoint_disposal_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def trigger_savepoint_disposal_with_http_info(self, body, **kwargs):  # noqa: E501
        """Triggers the desposal of a savepoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_savepoint_disposal_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SavepointDisposalRequest body: (required)
        :return: TriggerResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trigger_savepoint_disposal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `trigger_savepoint_disposal`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/savepoint-disposal', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TriggerResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_jar(self, jarfile, **kwargs):  # noqa: E501
        """Uploads a jar to the cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_jar(jarfile, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarfile: (required)
        :return: JarUploadResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_jar_with_http_info(jarfile, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_jar_with_http_info(jarfile, **kwargs)  # noqa: E501
            return data

    def upload_jar_with_http_info(self, jarfile, **kwargs):  # noqa: E501
        """Uploads a jar to the cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_jar_with_http_info(jarfile, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jarfile: (required)
        :return: JarUploadResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jarfile']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_jar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jarfile' is set
        if ('jarfile' not in params or
                params['jarfile'] is None):
            raise ValueError("Missing the required parameter `jarfile` when calling `upload_jar`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'jarfile' in params:
            local_var_files['jarfile'] = params['jarfile']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/jars/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JarUploadResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
